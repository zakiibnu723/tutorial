<!DOCTYPE html>  
<html lang="en">  
<head>  
    <title>three.js ar - hit test</title>  
    <meta charset="utf-8">  
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">  
    <link type="text/css" rel="stylesheet" href="main.css">  
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>  
</head>  
<body>  
  
<div id="content">  
    <div id="mySidenav" class="sidenav">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
        <a class="ar-object" id="1" href="#">item_1</a>
        <a class="ar-object" id="2" href="#">item_2</a>
        <a class="ar-object" id="3" href="#">item_3</a>
        <a class="ar-object" id="4" href="#">item_4</a>
        <a class="ar-object" id="yelow-sofa" href="#">yelow-sofa</a>
        <a class="ar-object" id="blue-chair" href="#">blue-chair</a>
        <a class="ar-object" id="arm-chair" href="#">arm-chair</a>
        <a class="ar-object" id="sofa1" href="#">sofa obj 1</a>
        <a class="ar-object" id="sofa-2b" href="#">sofa 2b </a>
        <a class="ar-object" id="uploads_files_3063858_Lounge+Chair+ITF" href="#">Lounge Chair</a>        
        <a class="ar-object" id="Memosofa" href="#">Memosofa obj</a>        
        <a class="ar-object" id="ImageToStl.com_sofa" href="#">sofa1 glb (imagetostl)</a>
    </div>
  
    <div id="container" style="position: fixed;"></div>  
  
    <span style="font-size:30px;cursor:pointer;position: absolute;" onclick="openNav()">&#9776; open</span>  
  
    <button type="button" id="place-button">PLACE</button>  
</div>  
  
<script>  
    function openNav() {  
        document.getElementById("mySidenav").style.width = "250px";  
    }  
  
    function closeNav() {  
        document.getElementById("mySidenav").style.width = "0";  
    }  
</script>  
  
<script type="module">  
    import * as THREE from './build/three.module.js';  
    import { ARButton } from './jsm/webxr/ARButton.js';  
    import { VRButton } from './jsm/webxr/VRButton.js';  
    import { OrbitControls } from './jsm/controls/OrbitControls.js';  
    import { GLTFLoader } from './jsm/loaders/GLTFLoader.js'; 
    import { OBJLoader } from './jsm/loaders/OBJLoader.js';   
    import { RGBELoader } from './jsm/loaders/RGBELoader.js';  
    import { RoughnessMipmapper } from './jsm/utils/RoughnessMipmapper.js';  
  
    var container;  
    var camera, scene, renderer;  
    var controller;  
    var reticle, pmremGenerator, current_object, controls, isAR, envmap;
    var shadowPlane;  
    var hitTestSource = null;  
    var hitTestSourceRequested = false;  
  
    init();  
    animate();  
  
    $(".ar-object").click(function(){  
        if(current_object != null){  
            scene.remove(current_object);  
        }  
        loadModel($(this).attr("id"));  
    });  
  
    $("#ARButton").click(function(){  
        current_object.visible = false;  
        isAR = true;  
    });  
  
    $("#VRButton").click(function(){  
        scene.background = envmap;  
        scene.position.z = -2;  
    });  
  
    $("#place-button").click(function(){  
        arPlace();  
    });  

function createShadowPlane() {
    const shadowPlane = new THREE.Mesh(
        new THREE.PlaneGeometry(20, 20),
        new THREE.ShadowMaterial({
            opacity: 0.5,
            transparent: true
        })
    );
    shadowPlane.rotation.x = -Math.PI / 2;
    shadowPlane.position.y = 0;
    shadowPlane.receiveShadow = true;
    return shadowPlane;
}
 // Modify your arPlace() function:
function arPlace() {
    if (reticle.visible) {
        // Remove existing shadow plane if it exists
        const existingShadow = scene.getObjectByName('shadowPlane');
        if (existingShadow) scene.remove(existingShadow);

        // Create and position shadow plane
        const shadowPlane = createShadowPlane();
        shadowPlane.name = 'shadowPlane';
        shadowPlane.position.setFromMatrixPosition(reticle.matrix);
        scene.add(shadowPlane);

        // Position the object
        current_object.position.setFromMatrixPosition(reticle.matrix);
        current_object.visible = true;

        // Update lighting to cast shadows
        const spotLight = scene.getObjectByProperty('type', 'SpotLight');
        if (spotLight) {
            spotLight.position.set(
                current_object.position.x + 5,
                current_object.position.y + 5,
                current_object.position.z + 5
            );
            spotLight.target = current_object;
        }
    }
}
  
// Modify your loadModel() function to ensure shadows are enabled:
function loadModel(model) {
    new RGBELoader()
        .setDataType(THREE.UnsignedByteType)
        .setPath('textures/')
        .load('photo_studio_01_1k.hdr', function(texture) {
            envmap = pmremGenerator.fromEquirectangular(texture).texture;
            scene.environment = envmap;
            texture.dispose();
            pmremGenerator.dispose();

            var loader = new GLTFLoader().setPath('3d/');
            loader.load(model + ".glb", function(glb) {
                current_object = glb.scene;
                
                // Enable shadows for all meshes
                current_object.traverse(node => {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                        if (node.material) {
                            node.material.shadowSide = THREE.FrontSide;
                        }
                    }
                });

                scene.add(current_object);
                arPlace();

                var box = new THREE.Box3();
                box.setFromObject(current_object);
                box.center(controls.target);

                controls.update();
                render();
            });
        });
}
    
    function init() {  
        container = document.createElement('div');  
        document.getElementById("container").appendChild(container);  
  
        scene = new THREE.Scene();  
        window.scene = scene;  
  
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.001, 200);  
  
        // Enhanced lighting setup
        const hemisphericLight = new THREE.HemisphereLight(0xffffff, 0x808080, 1);
        scene.add(hemisphericLight);

        // Main directional light for shadows
        const directionalLight = new THREE.DirectionalLight(0xffffff, 3);
        directionalLight.position.set(5, 5, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -5;
        directionalLight.shadow.camera.right = 5;
        directionalLight.shadow.camera.top = 5;
        directionalLight.shadow.camera.bottom = -5;
        directionalLight.shadow.bias = -0.0001;
        scene.add(directionalLight);

        // Fill light
        const fillLight = new THREE.DirectionalLight(0xffffff, 1);
        fillLight.position.set(-5, 3, -5);
        scene.add(fillLight);
  
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });  
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 1;
        renderer.setPixelRatio(window.devicePixelRatio);  
        renderer.setSize(window.innerWidth, window.innerHeight);  
        renderer.xr.enabled = true;  
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);  
  
        pmremGenerator = new THREE.PMREMGenerator(renderer);  
        pmremGenerator.compileEquirectangularShader();  
  
        controls = new OrbitControls(camera, renderer.domElement);  
        controls.addEventListener('change', render);  
        controls.minDistance = 2;  
        controls.maxDistance = 10;  
        controls.target.set(0, 0, -0.2);  
        controls.enableDamping = true;  
        controls.dampingFactor = 0.05;  
  
        // Create shadow plane
        createShadowPlane();
  
        document.body.appendChild(VRButton.createButton(renderer));  
  
        let options = {  
            requiredFeatures: ['hit-test'],  
            optionalFeatures: ['dom-overlay'],  
        }  
  
        options.domOverlay = { root: document.getElementById('content') };  
  
        document.body.appendChild(ARButton.createButton(renderer, options));  
  
        reticle = new THREE.Mesh(  
            new THREE.RingBufferGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),  
            new THREE.MeshBasicMaterial()  
        );  
        reticle.matrixAutoUpdate = false;  
        reticle.visible = false;  
        scene.add(reticle);  
  
        window.addEventListener('resize', onWindowResize, false);  
  
        // Touch event handlers
        var touchDown, touchX, touchY, deltaX, deltaY;  
  
        renderer.domElement.addEventListener('touchstart', function(e) {  
            e.preventDefault();  
            touchDown = true;  
            touchX = e.touches[0].pageX;  
            touchY = e.touches[0].pageY;  
        }, false);  
  
        renderer.domElement.addEventListener('touchend', function(e) {  
            e.preventDefault();  
            touchDown = false;  
        }, false);  
  
        renderer.domElement.addEventListener('touchmove', function(e) {  
            e.preventDefault();  
            if (!touchDown) return;  
            deltaX = e.touches[0].pageX - touchX;  
            deltaY = e.touches[0].pageY - touchY;  
            touchX = e.touches[0].pageX;  
            touchY = e.touches[0].pageY;  
            rotateObject();  
        }, false);  
    }  
  
    function rotateObject() {  
        if (current_object && reticle.visible) {  
            current_object.rotation.y += deltaX / 100;  
        }  
    }  
  
    function onWindowResize() {  
        camera.aspect = window.innerWidth / window.innerHeight;  
        camera.updateProjectionMatrix();  
        renderer.setSize(window.innerWidth, window.innerHeight);  
    }  
  
    function animate() {  
        renderer.setAnimationLoop(render);  
        requestAnimationFrame(animate);  
        controls.update();  
    }  
  
    function render(timestamp, frame) {  
        if (frame && isAR) {  
            var referenceSpace = renderer.xr.getReferenceSpace();  
            var session = renderer.xr.getSession();  
  
            if (hitTestSourceRequested === false) {  
                session.requestReferenceSpace('viewer').then(function(referenceSpace) {  
                    session.requestHitTestSource({ space: referenceSpace }).then(function(source) {  
                        hitTestSource = source;  
                    });  
                });  
  
                session.addEventListener('end', function() {  
                    hitTestSourceRequested = false;  
                    hitTestSource = null;  
                    isAR = false;  
                    reticle.visible = false;  
                    shadowPlane.visible = false;  
  
                    var box = new THREE.Box3();  
                    box.setFromObject(current_object);  
                    box.center(controls.target);  
  
                    document.getElementById("place-button").style.display = "none";  
                });  
  
                hitTestSourceRequested = true;  
            }  
  
            if (hitTestSource) {  
                var hitTestResults = frame.getHitTestResults(hitTestSource);  
  
                if (hitTestResults.length) {  
                    var hit = hitTestResults[0];  
                    document.getElementById("place-button").style.display = "block";  
                    reticle.visible = true;  
                    reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);  
                } else {  
                    reticle.visible = false;  
                    document.getElementById("place-button").style.display = "none";  
                }  
            }  
        }  
  
        renderer.render(scene, camera);  
    }  
</script>  
</body>  
</html>
